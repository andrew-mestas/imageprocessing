<!doctype html>
<html lang="en">
<head></head>
<style>
  video, canvas {
    border: 1px solid;
  }
  .container {
    display: flex;
    flex-direction: row;
  }
  .row{
    flex-direction: row;
    align-self: center;
  }
</style>
<body>
  <div class="container">
    <div class="row">
      <video id="video" width="320" height="240" autoplay></video>
      <canvas id="canvas" width="320" height="240"></canvas>
       <div class="row">
      <button id="begin">Begin Capturing</button>
      <button id="snap">Single Frame</button>
      <button id="clear">Stop</button>
      <button id="whitebalance">White Balance</button>
      <input type="checkbox" id="parallel">Parallel</input>
      <input type="number" min="0" id="number">Threads</input>
      <input type="button" value="Refresh" onClick="window.location.reload()">
    </div>
    </div>
    <div class="row">
      COLORS
      <div class="info"></div>      
      <div class="stats"></div>
      <canvas id="chart" width="320" height="240"></canvas>
      <canvas id="bar" width="320" height="240"></canvas>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.2.2/Chart.min.js"></script>
  <script src="files/chartdata.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.js"></script>
  <script src="files/imageProcess.3.js"></script>
  <script src="files/parallelHelpers.js"></script>
  <script>
    // shim layer with setTimeout fallback
    window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       ||
              window.webkitRequestAnimationFrame ||
              window.mozRequestAnimationFrame    ||
              function( callback ){
                window.setTimeout(callback, 1000 / 60);
              };
    })();
  var videoCanvas;
  var parallel;
  var coordsMatrix = [[110, 70, 50, 50], [180, 70, 50, 50]];
  var whiteBalance = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  var offline = false;
  var accumulatedTotals =[];
  var completed = 0;
  var start;
  var times = [];
  var time = new StopWatch;

  document.getElementById('begin').addEventListener("click", function() {
     var isParallel = document.getElementById("parallel").checked ? true : false;
     var numberOfThreads = parseInt(document.getElementById("number").value);
     videoCanvas = new VideoCanvas('video', 'canvas', {h: 320, w: 240, m: coordsMatrix, p: isParallel});
     if(isParallel){
      parallel = new PL(isParallel, numberOfThreads, './files/processParallel.js', accumulateTotals);
      parallel.begin();
     }     
     videoCanvas.startVideo();
  });

  // Trigger photo take
  document.getElementById('snap').addEventListener("click", function() {
    window.cancelAnimationFrame(animFrameID);    
    videoCanvas.drawVideoToCanvas();
  });

  // Clear Video source and erase canvas
  document.getElementById('whitebalance').addEventListener('click', function(){
    videoCanvas.drawVideoToCanvas();
    updateChart(VideoCanvas.context);
    storeWhiteBalance();
  });

  // Clear Video source and erase canvas
  document.getElementById('clear').addEventListener('click', function(){
    videoCanvas.clearCanvas();
    if(parallel&&parallel.isParallel){
      parallel.computeWorkers.forEach(function(worker){
        worker.terminate();
      });
      parallel.isParallel = false;
    }  
  });
      
    function accumulateTotals(data){
      accumulatedTotals[data.idx] = data.data;
      completed = completed + 1;
      if(completed === parallel.computeWorkers.length){
        end  = performance.now();
        var time = end - start;
        times.push(time);       
        completed = 0;
     
        parallelUpdate();
      }
    }

      function parallelUpdate(){
      // totalsC = totals;
      totals = accumulatedTotals;
      totals = totals.map(function(total){
        return total.map(function(v, i){return (v-whiteBalance[i] < 0) ? 0 : v-whiteBalance[i] });  
      })
      if(!offline){
        updateLine(totals[0]);
        updateBar(totals[1]);
      }
        document.getElementsByClassName("stats")[0].innerHTML = meanAndStandardDeviation(times).Mean;
      // socket.emit('raw data', {data: dataValues.data, height: dataValues.height, width: dataValues.width});
 
    }

    function updateChartParallel(context){
      var dataValues = context.getImageData(coordsMatrix[0][0], coordsMatrix[0][1], coordsMatrix[0][2], coordsMatrix[0][3]).data.buffer;
      var dataValues2 = context.getImageData(coordsMatrix[1][0], coordsMatrix[1][1], coordsMatrix[1][2], coordsMatrix[1][3]).data.buffer;
      // chunks.forEach(function(chunk, idx){
      var b = new ArrayBuffer(8);
      var c = new ArrayBuffer(8);
      var d = new ArrayBuffer(4);
      var t = new ArrayBuffer(4);
      var v = new Int32Array(b);
      var g = new Int32Array(c);
      var m = new Int32Array(d);
      var n = new Int32Array(t);
      v[0] = coordsMatrix[0][2];
      v[1] = coordsMatrix[0][3];
      g[0] = coordsMatrix[1][2];
      g[1] = coordsMatrix[1][3];
      m[0] = 0;
      n[0] = 1;
      var dimensionsBuffer = v.buffer;
      var dimensionsBuffer2 = g.buffer;
      var count1Buf = m.buffer;
      var count2Buf = n.buffer;

        parallel.computeWorkers[0].postMessage({values: dataValues, dim: dimensionsBuffer, idx: count1Buf}, [dataValues, dimensionsBuffer, count1Buf]);
        parallel.computeWorkers[1].postMessage({values: dataValues2, dim: dimensionsBuffer2, idx: count2Buf}, [dataValues2, dimensionsBuffer2, count2Buf]);

       start = performance.now();
     }


    function updateChart(context){
      // VideoCanvas.context.drawImage(video, 0, 0, 320, 240);
      var dataValues = context.getImageData(coordsMatrix[0][0], coordsMatrix[0][1], coordsMatrix[0][2], coordsMatrix[0][3]);
      var totals;
      time.Execute(function(){
        totals =  getTotals(dataValues);
        totalsC = totals;
        totals = totals.map(function(v, i){return (v-whiteBalance[i] < 0) ? 0 : v-whiteBalance[i] });  
      });
      
      if(!offline){
        updateLine(totals);
        updateBar(totals);
      } else {
        document.getElementsByClassName("info")[0].innerHTML = totals;
      }
        document.getElementsByClassName("stats")[0].innerHTML = meanAndStandardDeviation(time.times).Mean;
      // socket.emit('raw data', {data: dataValues.data, height: dataValues.height, width: dataValues.width});
    }
             
    function updateLine(totals){
      myLineChart.data.datasets[0].data = totals;
      myLineChart.update();
    }

    function updateBar(totals){
      myBarChart.data.datasets[0].data = totals;
      myBarChart.update();
    }


    function adjustScope(height, width, updown, leftright, idx){
      var h = height || coordsMatrix[idx][0];
      var w = width || coordsMatrix[idx][1];
      var u = updown || coordsMatrix[idx][2];
      var l = leftright || coordsMatrix[idx][3];
      coordsMatrix[idx][0] = h;
      coordsMatrix[idx][1] = w;
      coordsMatrix[idx][2] = u;
      coordsMatrix[idx][3] = l;
    }

      
   
  </script>
</body>
</html>